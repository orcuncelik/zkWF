/*
 * Copyright 2023 Contributors of the zkWF project
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "hashes/sha256/512bitPacked" as sha256packed;
import "hashes/sha256/512bit" as sha256h;
from "ecc/babyjubjubParams" import BabyJubJubParams;
import "signatures/verifyEddsa.zok" as verifyEddsa;
import "ecc/babyjubjubParams.zok" as context;
import "utils/casts/u32_to_field.zok" as u32_to_field;
import "utils/casts/field_to_u32.zok" as field_to_u32;

struct signed_field {
    field value;
    bool positive;
}

def signed_field_add(signed_field a,signed_field b) -> signed_field {
    field value = a.positive == b.positive ? a.value + b.value : (a.value > b.value ? a.value - b.value : b.value - a.value);
    bool positive = a.positive == b.positive ? a.positive : (a.value > b.value ? a.positive : b.positive);

    return signed_field{value: value, positive: positive};
}

def signed_field_sub(signed_field a,signed_field b) -> signed_field {
    signed_field temp = signed_field{value: b.value,positive: !b.positive};
    return signed_field_add(a,temp);
}

def signed_field_graterThan(signed_field a,signed_field b) -> bool {
    signed_field temp = signed_field_sub(a,b);
    return temp.positive;
}

def signed_field_lessThan(signed_field a,signed_field b) -> bool {
    return signed_field_graterThan(b,a);
}

def signed_field_graterThanZero(signed_field a) -> bool {
    return a.value > 0 && a.positive;
}
    
def signed_field_lessThanZero(signed_field a) -> bool {
    return a.value > 0 && !a.positive;
}

def signed_field_equal(signed_field a,signed_field b) -> bool {
    return a.value == b.value && b.positive == a.positive;
}

def signed_field_create(field v,bool p) -> signed_field {
    return signed_field{value: v,positive: p};
}

def isNothing(signed_field[2] a) -> bool {
    return a[0].value == 0 && a[1].value == 1 && !a[1].positive;
}
    
def Li_graterThan(signed_field[3] a,signed_field[3] b) -> bool {
    bool cond1 = signed_field_lessThan(a[1],b[1]) && !isNothing(a[0..2]) && !isNothing(b[0..2]);
    bool cond2 = signed_field_equal(a[1],b[1]) && signed_field_lessThan(a[2],b[2]) && !isNothing(a[0..2]) && !isNothing(b[0..2]);
    bool cond3 = isNothing(a[0..2]) && isNothing(b[0..2]) && signed_field_lessThan(a[2],b[2]);
    bool cond4 = !isNothing(a[0..2]) && isNothing(b[0..2]);
    return cond1 || cond2 || cond3 || cond4;
}
    
const signed_field signed_field_zero = signed_field{value: 0, positive:true};
const signed_field signed_field_one = signed_field{value: 1, positive:true};
const signed_field signed_field_negative_one = signed_field{value: 1, positive:false};
const signed_field[2] nothing = [signed_field{value: 0, positive:true},signed_field{value: 1, positive:false}];

[[ !!!REPLACE THIS WITH CONSTANTS!!! ]]

def main(u32[len_V] s_curr,u32[len_V] s_next) -> u32[4] {
    signed_field[3][2] mut changes = [nothing;3];
    u32[4] mut chres = [0;4];
    u32 mut change_count = 0;
    u32 mut pos = 0;

    for u32 i in 0..len_V {
        assert(s_curr[i] <= 2 && s_next[i] <= 2);
    }

    for u32 i in 0..len_V {
        u32 change_id = change_count <= 2 ? change_count : 0;

        changes[change_id] = s_curr[i] == s_next[i] ? changes[change_id] : (s_curr[i] == 1 && s_next[i] == 2 ? [signed_field{value: 1,positive: false},signed_field{value:u32_to_field(i),positive:true}] : (s_curr[i] == 0 && s_next[i] == 1 ? [signed_field{value: 1,positive: true},signed_field{value: u32_to_field(i),positive:true}] : (s_curr[i] == 0 && s_next[i] == 2 ? [signed_field{value: 1,positive: false},signed_field{value: u32_to_field(i),positive:true}] : [signed_field{value: 1,positive: false},signed_field{value: 1,positive:false}])));

        pos = (s_curr[i] != s_next[i] && !changes[change_id][0].positive) ? i : pos;
        chres[change_id] = s_curr[i] != s_next[i] ? i : chres[change_id];
        change_count = s_curr[i] != s_next[i] ? change_count + 1 : change_count;
    }

    chres[3] = pos;

    assert(change_count != 1 || pos != 0); // New tokens cannot be created by calling the start event again...
    assert(change_count <= 3);

    bool mut result = change_count == 0;

    for u32 i in 0..len_w {
        bool mut good = true;
        for u32 j in 0..3 {
            bool mut pair_found = false;
            for u32 k in 0..3 {
                pair_found = pair_found || (signed_field_equal(p[i][j][0],changes[k][0]) && signed_field_equal(p[i][j][1],changes[k][1]));
            }
            good = good && pair_found;
        }
        result = result || good;
    }

    for u32 i in 0..len_w {
        bool mut good = change_count == 1;
        u32 mut minusCount = 0;
        bool mut contains = false;
        u32 mut other = 0;

        for u32 j in 0..3 {
            bool is_minus = signed_field_equal(p[i][j][0],signed_field_create(1,false));
            minusCount = is_minus ? minusCount + 1 : minusCount;
            bool is_change = signed_field_equal(p[i][j][0],changes[0][0]) && signed_field_equal(p[i][j][1],changes[0][1]);
            contains = contains || is_change;
            bool is_other = signed_field_equal(p[i][j][0],changes[0][0]) && !signed_field_equal(p[i][j][1],changes[0][1]);
            other = is_other ? field_to_u32(p[i][j][1].value) : other;
        }

        good = good && (minusCount == 2 && contains && s_next[other] != 2);
        result = result || good;
    }

    assert(result);
    return chres;
}
